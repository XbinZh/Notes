2      变量和类型
原则4           谨慎使用静态成员变量

说明：要谨记，静态成员变量是属于类级别的变量，而不是属于某个对象实例。

错误使用静态成员变量可能有以下场景：

         1、认为静态变量是属于某个实例，而实际是多个实例操作同一个变量，造成值与预期不一致。

         2、没有注意静态变量的初始化顺序，读取还未初始化的静态变量值。例如下面代码的执行顺序是，A、第一行的INSTANCE被main方法触发，创建一个新的实例; B、类构造方法被触发，beltSize被计算，此时CURRENT_YEAR还是未初始化状态，默认值为0，导致beltSize被计算为-1930。

推荐在以下场景中，合理使用静态变量：

1、类的所有实例必须共享同一个变量时，比如，为实现某个任务，该类的所有实例共用的变量，如计数器等；

2、工具类提供的常量，如配置文件中的参数 "映射"到类的变量时，基本上第一次赋值后，数据不再被修改；

3、单例模式中应用。

规则16       避免随意进行类型强制转换，应改善设计，或在转换前用instanceof进行判断

说明：没有判断直接进行类型转换，可能会因类型不匹配而导致运行期异常

（instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。）

java.lang.ClassCastException。

简单的修改方法即是在强制转换之前使用instanceof进行判断，确认转换操作可行，但可能带来的问题是修改点过多，工作量巨大，同时维护的工作量也会倍增。最好的方式还是改善设计，使集合中只有同一种类型的对象。

规则17       需要精确计算时不要使用float和double

说明：浮点数在一个范围很广的值域上提供了很好的近似，但是它不能产生精确的结果。二进制浮点数对于精确计算是非常不适合的，因为它不可能将0.1，或者10的其它任何负次幂表示为一个长度有限的二进制小数。涉及精确的数值计算（货币、金融等），建议使用int, long, BigDecimal等

规则18       不能用浮点数作为循环变量

说明：浮点数不能为循环因子，精度问题会导致 (float)2000000000 == 2000000050为true，所以如下的循环不会执行

规则19       浮点型数据判断相等不能直接使用==

 说明：由于浮点数在计算机表示中存在精度的问题，因此，判断2个浮点数相等不能直接使用等号可以采用如下方式：Match.abs(a-b) < 1E-6f
  其中1E-6f为一个float极小值，实际使用时请根据情况判断精度，并且提取常量。  如果是double,请使用1E-6



规则20       避免同一个局部变量在前后表达不同的含义

说明：同一个局部变量在前后表达不同的含义，会使代码理解起来比较困难，不利于维护。一个局部变量只应该表达一种含义。

规则21       不要在单个的表达式中对相同的变量赋值超过一次

说明：对相同的变量进行多次赋值的表达式会产生混淆，并且很少能够产生你希望的行为。清晰的变量赋值会使代码更易懂，程序也会产生我们预期的行为。

建议8           基本类型优于包装类型，注意合理使用包装类型

说明：Java有两种类型，基本类型（Primitive type）和引用类型（Reference type）。基本类型如boolean,int, double，引用类型如String,List。每一种基本类型都有其对应的包装类型（Wrapper classes），如对应int的是Integer。

很多情况下基本类型优于装箱基本类型，因为：

1、在JDK 1.5以及之后的版本中增加了自动装箱和拆箱的特性。但是，不恰当的并行使用基本类型和包装类型，可能带来大量隐含的装箱和拆箱的操作。如下面的for语句中，由于循环变量是基本类型，而sum是包装类型，会导致频繁的自动装箱和拆箱操作，导致性能下降。
2、对于包装类型，使用“==”比较可能无法得到预期的结果。如：new Integer(42) ==new Integer(42) 将返回false。应该使用equals方法做装箱类型的比较。

1.基本数据类型他们之间的比较，应用双等号（==）,比较的是他们的值。 
2.复合数据类型(类) 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。

使用包装类型合理的场景有：

1、作为集合中的元素、键和值

2、泛型，必须使用包装类型，如List<Integer>

3、进行反射的方法调用时

 
